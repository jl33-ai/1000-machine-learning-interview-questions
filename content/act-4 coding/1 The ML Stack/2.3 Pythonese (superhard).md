> [!quote] Python 


---
##### What happens in the background when you run `for _ in mySet:`

iterators and generators

##### What is lazy evaluation? 

##### Who created Python, and when and why? 

##### What is `exit()`

##### What is the `<module>`
##### What are two ways to execute Python code from the terminal? 

`python -c "<code>"`

`python my_script.py`

<br>

---
##### What is a `float64`

```python
#   Column          Non-Null Count   Dtype 
--- ------          --------------   ----- 
0   fixed acidity   1599 non-null    float64
```

Used to represent **real numbers** (numbers with whole and decimal parts), using **64** bits. 

<br>

---
##### Asynchronous Programming

- Await
- Async
- Coroutine

<br>

---

##### How can you keep track of a variable across recursive function calls

Using a list (`index = [1]`) to keep track of the count is a clever way to handle the mutable state across recursive calls. However, it's not immediately obvious why a list is being used here instead of a simple integer. This could confuse someone not familiar with Python's handling of mutable default arguments.

<br>

---

##### When should you use recursive vs. iterative algorithms? 

<br>

---
##### venv: why, how. Alternatives: conda

https://www.freecodecamp.org/news/how-to-setup-virtual-environments-in-python/


<br>

---

##### The `collections library`


###### ↳  *Scenario*: Imagine you are working on a natural language processing project where you need to count the frequency of words in a large corpus of text. The words are tokenized and provided as a list of strings. How would you implement a solution for counting the frequency of each word efficiently? Specifically, explain which Python dictionary structure you would choose and why.

The candidate should mention using the `collections.Counter` class, explaining its efficiency in counting hashable objects and how it simplifies tasks involving counting occurrences, which is common in text processing and feature engineering in machine learning.

###### ↳  *Scenario*: Consider a machine learning model training process where you need to cache large amounts of intermediate data (like partial results or feature sets) for quick access. However, this data should not prevent the objects from being garbage-collected when they are no longer in use elsewhere to avoid memory leaks. Which Python dictionary type would you use to implement this caching mechanism and why?

The ideal answer would be either `weakref.WeakValueDictionary` or `weakref.WeakKeyDictionary`. The candidate should explain how these dictionaries store weak references to their items, allowing the garbage collector to remove items if there are no strong references to them elsewhere, thus efficiently managing memory during intensive computation tasks like model training.


###### ↳  *Scenario*: Imagine you have a collection of documents (like articles, web pages, or papers) and you want to quickly find all documents that contain a particular word. To do this efficiently, you can build an inverted index that maps each word to a list of document IDs where that word appears. Use `defaultdict`


<br>

---

##### What type of object does `dict.values()` return? 

While `dict.values()` is able to show you all of the values in a dictionairy, the object itself is **not** a list object but rather a `view` object. 

> [!check] `view`
> 1. In Python, a view object is a special kind of object returned by certain methods of dictionary-like types (`dict`, `defaultdict`, etc.). These objects provide a **dynamic view** on the dictionary's entries
> 1. By **dynamic** this means that if you modify the dictionary after creating a view, the changes will be visible in the view. For instance, if you add a new key-value pair to a dictionary, this pair will appear in an existing view created from `dict.items()`.
    
2. **Iterable**: View objects are iterable. You can loop over them to access their elements. For example, you can iterate over a `dict.values()` view to access all the values in the dictionary.
    
3. **Not a List**: Despite being iterable, a view object is not a list. It does not store all its elements in memory; it dynamically queries the underlying dictionary. If you need a list, you can explicitly convert a view object to a list with `list(view_object)`.
    
4. **Efficiency**: Because they don't make a copy of the keys or values, view objects are more memory-efficient than manually creating a list of keys or values, especially for large dictionaries.